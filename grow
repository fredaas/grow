#!/usr/bin/env python3

# TODO: Fix [Errno 32] Broken pipe:
#
# https://stackoverflow.com/questions/14207708/ioerror-errno-32-broken-pipe-python
#

import glob
import re
import os
import sys
import stat
import argparse

global_show_path    = False
global_show_size    = False
global_search_depth = 20

info_max_depth = 0
info_num_files = 0
info_size      = 0

exclude_list = []

search_pattern = None

rshift = 4

def indent_factor(s, indent):
    i = 0
    while s[i] == " ":
        i += 1
    return (int)(i / indent)


class Node:
    """
    File node

    name

        File name.

    depth

        File's depth in directory tree.

    index

        File's index in input stream.
    """
    def __init__(self, name, depth, index):
        self.children = []
        self.parents = []
        self.name = name.strip()
        self.depth = depth
        self.index = index
        self.error = 0

    def push_parent(self, p):
        self.parents += p

    def push_child(self, c):
        self.children.append(c)

def show_tree(root):
    """
    Prints tree at 'root'

    Parameters:

        root

            Root node.
    """
    if root.depth != 0:
        print(" " * ((root.depth - 1) * rshift), end = "")
        print("{} {}".format(root.name, "" if root.error == 0 else "[FAILED]"))
    for node in root.children:
        show_tree(node)

def write_tree(root):
    """
    Writes tree at 'root'

    Parameters:

        root

            Root node.
    """
    if root.depth != 0:
        relpath = os.path.join(*root.parents, root.name)
        # This is a file node
        if "." in root.name:
            try:
                abspath = os.path.abspath(relpath)
                open(abspath, "w")
            except:
                root.error = 1
                print("[INFO] Failed to create the file '{}'"
                    .format(relpath))
        # This is directory node
        else:
            try:
                abspath = os.path.abspath(
                    os.path.join(*root.parents, root.name))
                os.makedirs(abspath)
            except:
                root.error = 1
                print("[INFO] Failed to create the directory '{}'"
                    .format(relpath))

    for node in root.children:
        write_tree(node)

def create_tree(root, stream, start, length, indent):
    """
    Builds tree at 'root'

    Parameters:

        root

            Root node.

        stream

            Input list.

        start

            Stream list index.

        length

            Stream length.

        indent

            Indentation factor.
    """
    for i in range(start, length):
        next_name = stream[i]
        next_depth = indent_factor(next_name, indent) + 1
        if next_depth == root.depth + 1:
            node = Node(next_name, next_depth, i)
            if root.depth > 0:
                node.push_parent(root.parents + [root.name])
            root.push_child(node)
    for child in root.children:
        create_tree(child, stream, child.index + 1, length, indent)

def valid_indent(stream):
    """
    Validates input-stream indentation levels

    -1 is returned if alternate indentation levels are detected. Otherwise the
    indentation level of the first indented element in the stream is returned.
    If the stream represents a flat directory structure, the indentation level
    is set to 1.

    Parameters:

        stream

            Input stream.
    """
    i = 0
    m = None
    for name in stream:
        i += 1
        lspace = len(name) - len(name.lstrip())
        # First file cannot be indented
        if i == 1 and lspace != 0:
            return -1
        # Save the indent of the first indented element in the stream
        elif i > 1 and lspace > 0 and m is None:
            m = lspace
            break

    # We have a flat directory structure
    if m is None:
        return 1

    i = 0
    for name in stream:
        i += 1
        lspace = len(name) - len(name.lstrip())
        # Check for alternate indentation levels. Multiply by 2 to allow for
        # single space/tabs indents.
        if (lspace * 2) % (m * 2) != 0:
            return -1
    return m

def parse_tree_input():
    """
    Creates directory tree from stdin input stream
    """
    stream = sys.stdin.read().rstrip().split("\n")

    indent = valid_indent(stream)

    if indent == -1:
        print("[ERROR] Detected alternate indentation levels")
        quit(1)

    root = Node("root", 0, 0)
    create_tree(root, stream, 0, len(stream), indent)
    write_tree(root)
    print("[INFO] Created directory tree:")
    show_tree(root)

def get_files(dir):
    """
    Returns the contents of 'dir' non-recursively

    Parameters:

        dir

            Directory.
    """
    files = []
    for target in search_pattern.format(dir).split(" "):
        files.extend(glob.glob(target, recursive = False))
    return files

def usize(bytes):
    """
    Returns the unit size of 'bytes' as a string

    Parameters:

        bytes

            File size in bytes.
    """
    if bytes > 1e+9:
        return "{:.1f} {}".format(bytes / 1e+9, "GiB")
    elif bytes > 1e+6:
        return "{:.1f} {}".format(bytes / 1e+6, "MiB")
    elif bytes > 1e+3:
        return "{:.1f} {}".format(bytes / 1e+3, "KiB")
    else:
        return "{} {}".format(bytes, "Byte")

def traverse_tree(file, depth):
    """
    Performs depth-first search on 'root' and prints its contents

    Parameters:

        file

            File to expand.

        depth

            Maximum search depth.
    """
    if depth > global_search_depth:
        return

    isdir = os.path.isdir(file)
    string = None

    # Show absolute path
    if global_show_path:
        string = os.path.abspath(file)
    else:
        string = os.path.basename(file)

    # Show file size
    if global_show_size and not isdir:
        try:
            string = string + " {}".format(usize(os.stat(file).st_size))
        except OSError:
            pass

    if global_show_path:
        print(string + "/" * isdir)
    else:
        print(" " * depth * rshift + string + "/" * isdir)

    if os.path.basename(file) in exclude_list:
        return

    for file in sorted(get_files(file), key=str):
        if isdir:
            traverse_tree(file, depth + 1)

def traverse_tree_info(root, depth):
    """
    Performs depth-first on 'root' and gathers information about its directory
    structure

    Parameters:

        root

            Root file.

        depth

            Current search depth.
    """
    global info_max_depth
    global info_num_files
    global info_size

    info_max_depth += (depth > info_max_depth)

    for file in get_files(root):
        if os.path.basename(file) in exclude_list:
            continue
        if os.path.isdir(file):
            traverse_tree_info(file, depth + 1)
        else:
            info_num_files += 1
            try:
                info_size += os.stat(file).st_size
            except OSError:
                pass

def print_tree_info(files):
    """
    Prints directory information

    Parameters:

        files

            Files to include in report.
    """
    global info_max_depth
    global info_num_files
    global info_size

    for file in files:
        if not os.path.isdir(file):
            continue

        info_max_depth = 0
        info_num_files = 0
        info_size = 0
        traverse_tree_info(file, 1)

        print("{}\n    depth: {}, files: {}, size: {}\n".format(
            os.path.basename(file),
            info_max_depth,
            info_num_files,
            usize(info_size)
        ))

def init_argparse():
    """
    Initializes the argument parser
    """
    parser = argparse.ArgumentParser()

    # Report directory information
    parser.add_argument(
        "-i",
        "--info",
        action = "store_true",
        required = False
    )

    # Maximum search depth
    parser.add_argument(
        "-d",
        "--depth",
        type = int,
        required = False
    )

    # Exclude files
    parser.add_argument(
        "-e",
        "--exclude",
        type = str,
        required = False
    )

    # Include dotfiles in search
    parser.add_argument(
        "-a",
        "--all",
        action = "store_true",
        required = False
    )

    # Expand basenames to absolute path
    parser.add_argument(
        "-p",
        "--path",
        action = "store_true",
        required = False
    )

    # Show file sizes
    parser.add_argument(
        "-s",
        "--size",
        action = "store_true",
        required = False
    )

    # Create directory structure
    parser.add_argument(
        "-c",
        "--create",
        action = "store_true",
        required = False
    )

    # Specify root directories
    parser.add_argument(
        "root",
        nargs = "*"
    )

    return vars(parser.parse_args())

if __name__ == "__main__":
    argv = init_argparse()

    if argv["create"]:
        parse_tree_input()
        quit(0)

    global_show_path = argv.get("path")
    global_show_size = argv.get("size")

    if argv.get("all"):
        search_pattern = "{0}/* {0}/.*"
    else:
        search_pattern = "{}/*"

    if argv.get("depth"):
        global_search_depth = argv.get("depth")

    if argv.get("exclude"):
        exclude_list = argv.get("exclude").split(",")

    files = argv.get("root")

    if len(files) == 0:
        files = get_files(".")

    files = [ x.rstrip("/") for x in files ]

    if argv.get("info"):
        print_tree_info(files)
        quit(0)

    for file in sorted(files, key=str):
        traverse_tree(file, 0)
