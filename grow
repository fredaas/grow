#!/usr/bin/env python3

import glob
import os
import sys
import stat
import argparse

GLOBAL_SHOW_PERMS = False
GLOBAL_SHOW_PATH = False
GLOBAL_SHOW_SIZE = False
GLOBAL_SEARCH_DEPTH = 20

exclude_list = None

class Node:
    def __init__(self, name, level, index):
        self.children = []
        self.parents = []
        self.name = name.strip()
        self.level = level
        self.index = index
        self.error = 0

    def push_parent(self, p):
        self.parents += p

    def push_child(self, c):
        self.children.append(c)

def lspaces(s):
    """
Returns the number of leading spaces for 's'

Parameters:

    s

        The string for which to compute the number of leading spaces.
    """
    return len(s) - len(s.lstrip())

def show_tree(root, m):
    """
Prints the AST representation of the directory tree

Parameters:

    root

        The root node from which to start the search.

    m

        The indentation factor.
    """
    if root.level != 0:
        print(" " * (root.level - m), end = "")
        print("{} {}".format(root.name, "" if root.error == 0 else "[ERROR]"))
    for node in root.children:
        show_tree(node, m)

def plant_tree(root, m):
    """
Creates files and directories from the AST representation of the directory tree

Parameters:

    root

        The root node from which to start the search.

    m

        The indentation factor.
    """
    if root.level != 0:
        relpath = os.path.join(*root.parents, root.name)
        # This is a file node
        if "." in root.name:
            try:
                abspath = os.path.abspath(relpath)
                open(abspath, "w")
            except:
                root.error = 1
                print("[INFO] Failed to create the file '{}'".format(relpath))
        # This is directory node
        else:
            try:
                abspath = os.path.abspath(
                    os.path.join(*root.parents, root.name))
                os.makedirs(abspath)
            except:
                root.error = 1
                print("[INFO] Failed to create the directory '{}'" \
                    .format(relpath))

    for node in root.children:
        plant_tree(node, m)

def grow_tree(root, stream, j, n, m):
    """
Builds directory tree from the stream mounted at 'root'

Parameters:

    root

        The root node.

    j
        The starting index of the candidate list.

    stream

        The candidate list.

    n

        Number of candidates in the list.

    m

        The indentation factor.
    """
    for i in range(j, n):
        name = stream[i]
        level = lspaces(name) + m
        if level == root.level:
            break
        elif level == root.level + m:
            node = Node(name, level, i)
            if root.level > 0:
                node.push_parent(root.parents + [root.name])
            root.push_child(node)
    for child in root.children:
        grow_tree(child, stream, child.index + 1, n, m)

def valid_indent(stream):
    """
Detects and validates the indentations levels of the input stream

-1 is returned if alternate indentation levels are detected. Otherwise the
indentation level of the first indented element in the stream is returned. If
the stream represents a flat directory structure, the indentation level is set
to 1.
    """
    i = 0
    m = None
    for name in stream:
        i += 1
        lspace = len(name) - len(name.lstrip())
        # First file cannot be indented
        if i == 1 and lspace != 0:
            return -1
        # Save the indent of the first indented element in the stream
        elif i > 1 and lspace > 0 and m is None:
            m = lspace
            break

    # We have a flat directory structure
    if m is None:
        return 1

    i = 0
    for name in stream:
        i += 1
        lspace = len(name) - len(name.lstrip())
        # Check for alternate indentation levels. Multiply by 2 to allow for
        # single space/tabs indents.
        if (lspace * 2) % (m * 2) != 0:
            return -1
    return m

def parse_tree_input():
    """
Builds an AST from the grammar given through stdin, and creates files and
directories corresponding to those nodes
    """
    stream = sys.stdin.read().rstrip().split("\n")

    m = valid_indent(stream)

    if m == -1:
        print("[ERROR] Detected alternate indentation levels")
        quit(1)

    root = Node("root", 0, 0)
    grow_tree(root, stream, 0, len(stream), m)
    plant_tree(root, m)

    print("[INFO] Created directory tree:")

    show_tree(root, m)

def ascii_perms(file):
    """
Returns the system privileges for 'file' in standard POSIX form, e.g.

    rw-r-x-wx

Parameters:

    file

        Absolute or relative path of the file to generate permissions for
    """
    _, oct_perms = oct(stat.S_IMODE(os.lstat(file).st_mode)).split("o")

    bin_perms = ""
    for digit in oct_perms:
        bin_perms += "{:03b}".format(int(digit))

    symbols = "rwx" * 3
    ascii_perms = ""
    for x, y in zip(bin_perms, symbols):
        if x == "1":
            ascii_perms += y
        else:
            ascii_perms += "-"

    return ascii_perms

def byte_order(file):
    """
Returns the size of 'file' along with its postfix

    file

        Absolute or relative path of the file to generate permissions for
    """
    bytes = os.path.getsize(file)
    if bytes > 1e+9 / 2:
        return "{:1.f} {}".format(bytes / 1e+9, "GiB")
    elif bytes > 1e+6 / 2:
        return "{:1.f} {}".format(bytes / 1e+6, "MiB")
    else:
        return "{} {}".format(bytes, "Byte")

def traverse_tree(root, depth):
    """
Performs a depth-first search given an initial 'root' directory

Parameters:

    root

        Top level directory from which to start the search.

    depth

        The maximum search depth.
    """
    for file in glob.glob(os.path.join(root, "*"), recursive = False):
        if depth > GLOBAL_SEARCH_DEPTH - 1:
            return

        is_dir = os.path.isdir(file)
        s = None

        if GLOBAL_SHOW_PATH:
            s = os.path.abspath(file)
        else:
            s = os.path.basename(file)

        if GLOBAL_SHOW_PERMS:
            if is_dir:
                s = "d{} ".format(ascii_perms(s)) + s
            else:
                s = "-{} ".format(ascii_perms(s)) + s

        if GLOBAL_SHOW_SIZE:
            if not is_dir:
                s = s + " {}".format(byte_order(file))

        if not GLOBAL_SHOW_PATH:
            print(" " * depth * 4, end = "")

        print(s)

        # Do not expand directory if in excluded list
        if exclude_list is not None:
            basename = os.path.basename(s)
            if basename in exclude_list:
                return

        if is_dir:
            traverse_tree(file, depth + 1)

def init_argparse():
    """
Instantiates the argument parser
    """
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-d",
        "--depth",
        type = int,
        required = False
    )

    parser.add_argument(
        "-e",
        "--exclude",
        type = str,
        required = False
    )

    parser.add_argument(
        "-p",
        "--permissions",
        action = "store_true",
        required = False
    )

    parser.add_argument(
        "-a",
        "--absolute",
        action = "store_true",
        required = False
    )

    parser.add_argument(
        "-s",
        "--size",
        action = "store_true",
        required = False
    )

    # Mutually exclusive
    parser.add_argument(
        "-c",
        "--create",
        action = "store_true",
        required = False
    )

    parser.add_argument(
        "root",
        nargs = "+"
    )

    return vars(parser.parse_args())

if __name__ == "__main__":
    argv = init_argparse()

    if argv["create"]:
        parse_tree_input()
        quit(0)

    GLOBAL_SHOW_PERMS = argv.get("permissions")
    GLOBAL_SHOW_PATH = argv.get("absolute")
    GLOBAL_SHOW_SIZE = argv.get("size")

    if argv.get("depth") is not None:
        GLOBAL_SEARCH_DEPTH = argv.get("depth")

    if argv.get("exclude") is not None:
        exclude_list = argv.get("exclude").split(",")

    files = argv.get("root")

    for file in files:
        is_dir = os.path.isdir(file)

        s = file

        if GLOBAL_SHOW_PATH:
            s = os.path.abspath(file)

        if GLOBAL_SHOW_PERMS:
            if is_dir:
                s = "d{} ".format(ascii_perms(file)) + s
            else:
                s = "-{} ".format(ascii_perms(file)) + s

        if GLOBAL_SHOW_SIZE:
            if not is_dir:
                s = s + " {}".format(byte_order(file))

        print(s)

        traverse_tree(file, 1)
