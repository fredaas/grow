#!/usr/bin/env python2

from __future__ import print_function

import glob
import re
import os
import sys
import stat
import argparse

GLOBAL_REPORT_DEPTH = False
GLOBAL_SHOW_PERMS   = False
GLOBAL_SHOW_PATH    = False
GLOBAL_SHOW_SIZE    = False
GLOBAL_SEARCH_DEPTH = 20

info_max_depth = 1
info_num_files = 0
info_size      = 0

exclude_list = None

search_pattern = None

class Node:
    def __init__(self, name, level, index):
        self.children = []
        self.parents = []
        self.name = name.strip()
        self.level = level
        self.index = index
        self.error = 0

    def push_parent(self, p):
        self.parents += p

    def push_child(self, c):
        self.children.append(c)

def lspaces(s):
    """
Returns the number of leading spaces for 's'

Parameters:

    s

        The string for which to compute the number of leading spaces.
    """
    return len(s) - len(s.lstrip())

def show_tree(root, m):
    """
Prints the AST representation of the directory tree

Parameters:

    root

        The root node from which to start the search.

    m

        The indentation factor.
    """
    if root.level != 0:
        print(" " * (root.level - m), end = "")
        print("{} {}".format(root.name, "" if root.error == 0 else "[ERROR]"))
    for node in root.children:
        show_tree(node, m)

def plant_tree(root, m):
    """
Creates files and directories from the AST representation of the directory tree

Parameters:

    root

        The root node from which to start the search.

    m

        The indentation factor.
    """
    if root.level != 0:
        relpath = os.path.join(*(root.parents + [root.name]))
        # This is a file node
        if "." in root.name:
            try:
                abspath = os.path.abspath(relpath)
                open(abspath, "w")
            except:
                root.error = 1
                print("[INFO] Failed to create the file '{}'".format(relpath))
        # This is directory node
        else:
            try:
                abspath = os.path.abspath(
                    os.path.join(*(root.parents + [root.name])))
                os.makedirs(abspath)
            except:
                root.error = 1
                print("[INFO] Failed to create the directory '{}'" \
                    .format(relpath))

    for node in root.children:
        plant_tree(node, m)

def grow_tree(root, stream, j, n, m):
    """
Builds directory tree from the stream mounted at 'root'

Parameters:

    root

        The root node.

    j
        The starting index of the candidate list.

    stream

        The candidate list.

    n

        Number of candidates in the list.

    m

        The indentation factor.
    """
    for i in range(j, n):
        name = stream[i]
        level = lspaces(name) + m
        if level == root.level:
            break
        elif level == root.level + m:
            node = Node(name, level, i)
            if root.level > 0:
                node.push_parent(root.parents + [root.name])
            root.push_child(node)
    for child in root.children:
        grow_tree(child, stream, child.index + 1, n, m)

def valid_indent(stream):
    """
Detects and validates the indentations levels of the input stream

-1 is returned if alternate indentation levels are detected. Otherwise the
indentation level of the first indented element in the stream is returned. If
the stream represents a flat directory structure, the indentation level is set
to 1.

Parameters:

    stream

        Input stream.
    """
    i = 0
    m = None
    for name in stream:
        i += 1
        lspace = len(name) - len(name.lstrip())
        # First file cannot be indented
        if i == 1 and lspace != 0:
            return -1
        # Save the indent of the first indented element in the stream
        elif i > 1 and lspace > 0 and m is None:
            m = lspace
            break

    # We have a flat directory structure
    if m is None:
        return 1

    i = 0
    for name in stream:
        i += 1
        lspace = len(name) - len(name.lstrip())
        # Check for alternate indentation levels. Multiply by 2 to allow for
        # single space/tabs indents.
        if (lspace * 2) % (m * 2) != 0:
            return -1
    return m

def parse_tree_input():
    """
Builds an AST from the grammar given through stdin, and creates files and
directories corresponding to those nodes
    """
    stream = sys.stdin.read().rstrip().split("\n")

    m = valid_indent(stream)

    if m == -1:
        print("[ERROR] Detected alternate indentation levels")
        quit(1)

    root = Node("root", 0, 0)
    grow_tree(root, stream, 0, len(stream), m)
    plant_tree(root, m)

    print("[INFO] Created directory tree:")

    show_tree(root, m)

def get_files(dir):
    """
Returns the contents of 'dir' non-recursively

Parameters:

    dir

        Directory to expand.
    """
    files = []
    for target in search_pattern.format(dir).split(" "):
        files.extend(glob.glob(target))
    return files

def ascii_perms(file):
    """
Returns the system privileges for 'file' in standard POSIX form

Parameters:

    file

        Path of the file to generate permissions for.
    """
    oct_perms = oct(stat.S_IMODE(os.lstat(file).st_mode)).split("o")

    bin_perms = ""
    for digit in oct_perms:
        bin_perms += "{:03b}".format(int(digit))

    symbols = "rwx" * 3
    ascii_perms = ""
    for x, y in zip(bin_perms, symbols):
        if x == "1":
            ascii_perms += y
        else:
            ascii_perms += "-"

    return ascii_perms

def byte_order(bytes):
    """
Converts the size of 'bytes' into an order of magnitude and returns the value as
a string together with its corresponding suffix

Parameters:

    bytes

        Size in bytes.
    """
    if bytes > 1e+9:
        return "{:.1f} {}".format(bytes / 1e+9, "GiB")
    elif bytes > 1e+6:
        return "{:.1f} {}".format(bytes / 1e+6, "MiB")
    elif bytes > 1e+3:
        return "{:.1f} {}".format(bytes / 1e+3, "KiB")
    else:
        return "{} {}".format(bytes, "Byte")

def is_excluded(dir):
    """
Returns 'True' if 'dir' should be excluded from the search, otherwise 'False'

Paramters:

    dir

        Name of the directory to check for exclusion.
    """
    if exclude_list is not None:
        basename = os.path.basename(dir)
        if basename in exclude_list:
            return True
    return False

def traverse_tree(root, depth):
    """
Performs a depth-first search given an initial 'root' directory

Parameters:

    root

        Top level directory from which to start the search.

    depth

        The maximum search depth.
    """
    if depth > GLOBAL_SEARCH_DEPTH - 1:
        return

    for file in get_files(root):
        is_dir = os.path.isdir(file)
        s = None

        if GLOBAL_SHOW_PATH:
            s = os.path.abspath(file)
        else:
            s = os.path.basename(file)

        if GLOBAL_SHOW_PERMS:
            if is_dir:
                s = "d{} ".format(ascii_perms(os.path.abspath(file))) + s
            else:
                s = "-{} ".format(ascii_perms(os.path.abspath(file))) + s

        if GLOBAL_SHOW_SIZE:
            if not is_dir:
                s = s + " {}".format(byte_order(os.stat(file).st_size))

        if not GLOBAL_SHOW_PATH:
            print(" " * depth * 4, end = "")

        print(s)

        if is_excluded(file):
            return

        if is_dir:
            traverse_tree(file, depth + 1)

def traverse_tree_info(root, depth):
    """
Performs a depth-first search given an initial 'root' directory and gathers
information about the directory structure and its contents

Parameters:

    root

        Top level directory from which to start the search.

    depth

        The current search depth.
    """

    global info_max_depth
    global info_num_files
    global info_size

    info_max_depth += (depth > info_max_depth)

    for file in get_files(root):
        if os.path.isdir(file):
            traverse_tree_info(file, depth + 1)
        else:
            info_num_files += 1
            info_size += os.stat(file).st_size

def init_argparse():
    """
Instantiates the argument parser
    """
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-i",
        "--info-report",
        action = "store_true",
        required = False
    )

    # Maximum search depth
    parser.add_argument(
        "-d",
        "--depth",
        type = int,
        required = False
    )

    # Exclude files
    parser.add_argument(
        "-e",
        "--exclude",
        type = str,
        required = False
    )

    # Show file permissions
    parser.add_argument(
        "-r",
        "--rights",
        action = "store_true",
        required = False
    )

    # Show file permissions
    parser.add_argument(
        "-a",
        "--all",
        action = "store_true",
        required = False
    )

    # Show absolute paths
    parser.add_argument(
        "-p",
        "--path",
        action = "store_true",
        required = False
    )

    # Show file sizes
    parser.add_argument(
        "-s",
        "--size",
        action = "store_true",
        required = False
    )

    # Create directory structure
    parser.add_argument(
        "-c",
        "--create",
        action = "store_true",
        required = False
    )

    # Specify root directories
    parser.add_argument(
        "root",
        nargs = "*"
    )

    return vars(parser.parse_args())

if __name__ == "__main__":
    argv = init_argparse()

    if argv["create"]:
        parse_tree_input()
        quit(0)

    GLOBAL_SHOW_PERMS = argv.get("rights")
    GLOBAL_SHOW_PATH = argv.get("path")
    GLOBAL_SHOW_SIZE = argv.get("size")
    GLOBAL_REPORT_DEPTH = argv.get("info_report")

    if argv.get("all"):
        search_pattern = "{0}/* {0}/.*"
    else:
        search_pattern = "{}/*"

    if argv.get("depth") is not None:
        GLOBAL_SEARCH_DEPTH = argv.get("depth")

    if argv.get("exclude") is not None:
        exclude_list = argv.get("exclude").split(",")

    files = argv.get("root")

    if len(files) == 0:
        files = get_files(".")
    else:
        files = [ re.sub('[\\/( )+$]', '', x) for x in files ]

    if argv.get("report_depth"):
        print("REPORT [depth, files, size]:\n")

        for file in files:
            if not os.path.isdir(file):
                continue

            info_max_depth = 1
            info_num_files = 0
            info_size = 0
            traverse_tree_info(file, 1)

            print(
            "{}\n    {}, {}, {}\n".format(
                os.path.basename(file),
                info_max_depth,
                info_num_files,
                byte_order(info_size)
            ))

        quit(0)

    for file in files:
        is_dir = os.path.isdir(file)
        s = None

        if GLOBAL_SHOW_PATH:
            s = os.path.abspath(file)
        else:
            s = os.path.basename(file)

        if GLOBAL_SHOW_PERMS:
            if is_dir:
                s = "d{} ".format(ascii_perms(os.path.abspath(file))) + s
            else:
                s = "-{} ".format(ascii_perms(os.path.abspath(file))) + s

        if GLOBAL_SHOW_SIZE:
            if not is_dir:
                s = s + " {}".format(byte_order(os.stat(file).st_size))

        print(s)

        if is_excluded(file):
            continue

        traverse_tree(file, 1)
